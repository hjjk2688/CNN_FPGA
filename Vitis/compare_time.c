//PS - ARM Cortex-A9 와 FPGA CNN IP 속도 비교

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xtime_l.h"   // 타이머 라이브러리 (Zybo Z7 필수)

// ==========================================================================
// 1. 하드웨어 스펙 정의 (Verilog Parameter와 동일하게 맞춤)
// ==========================================================================
#define CPU_CLOCK_HZ 666666667  // ARM Core: 667 MHz
#define PL_CLOCK_HZ  10000000   // FPGA PL:  10 MHz (수정됨!)

#define IMG_ROWS 28
#define IMG_COLS 28
#define CONV1_ROWS 24
#define CONV1_COLS 24
#define POOL1_ROWS 12
#define POOL1_COLS 12
#define CONV2_ROWS 8
#define CONV2_COLS 8
#define POOL2_ROWS 4
#define POOL2_COLS 4
#define FC_INPUT_NODES 48
#define FC_OUTPUT_NODES 10

// --------------------------------------------------------------------------
// [가중치 변환 가이드]
// Verilog: 8'shCD (-51), 8'sh88 (-120) ...
// C언어  : (signed char)0xCD, (signed char)0x88 ...
// --------------------------------------------------------------------------

// --- Conv1 Weights (5x5, 3 Filters) ---
// 님께서 올려주신 conv1_calc.v 값을 변환했습니다.
const signed char W_conv1[3][5][5] = {
    { // Filter 1
        {0, -51, -7, -17, 7}, {67, -17, -35, -18, 19}, {49, 56, 52, 25, -2},
        {17, 12, -2, -56, -77}, {-16, -31, 16, 60, 127}
    },
    { // Filter 2
        {30, 38, 36, 46, -26}, {27, -30, 1, 33, 1}, {43, -1, 21, 4, 13},
        {15, -27, -23, -34, 45}, {-17, -14, 0, 19, 25}
    },
    { // Filter 3
        {31, 47, 30, 25, 23}, {8, 3, -6, 14, 40}, {-69, 53, 63, 54, 5},
        {-58, -43, 4, -5, -22}, {-123, -128, -128, -128, -128}
    }
};
// Conv1 Bias (b1=0x88, b2=0x00, b3=0x00)
const signed char B_conv1[3] = {-120, 0, 0};


// --- Conv2 Weights (5x5x3, 3 Filters) ---
// 님께서 올려주신 conv2_calc_1.v 값을 변환했습니다. (나머지는 채워주세요!)
const signed char W_conv2[3][3][5][5] = { // [Filter][Channel][Row][Col]
    { // [Filter 1] (conv2_calc_1.v)
        { // Ch1
            {48, 69, 68, 48, 38}, {48, 46, 50, 31, 8}, {41, 22, 14, -16, -36},
            {3, -21, -26, -22, -34}, {-66, -16, -10, -1, -6}
        },
        { // Ch2
            {-2, 3, -17, 6, -3}, {-17, -6, 11, 23, 45}, {-22, -2, 36, 40, 53},
            {4, -3, 3, 17, 11}, {-30, -36, -12, 10, 14}
        },
        { // Ch3
            {11, 49, 70, 64, -90}, {5, 53, 41, -41, -96}, {40, 45, -19, -49, 0},
            {63, -51, -27, -10, 14}, {11, -34, 16, 9, 14}
        }
    },
{ // [Filter 2] conv2_calc_2.v 내용 반영
        { {43,9,12,-8,-35}, {21,33,43,31,13}, {21,35,51,57,28}, {5,21,32,37,13}, {15,29,23,4,-17} }, // Ch1
        { {-3,4,41,18,33}, {17,36,54,48,52}, {1,25,45,48,45}, {-14,1,36,42,19}, {17,26,27,7,19} }, // Ch2
        { {-36,-37,-47,-33,-25}, {-8,-15,-53,-39,-39}, {-8,-33,-62,-51,-33}, {6,-27,-40,-40,13}, {-1,-46,-44,-13,-13} } // Ch3
    },
    { // [Filter 3] conv2_calc_3.v 내용 반영
        { {-31,53,30,30,43}, {6,18,18,16,16}, {7,0,-2,-25,3}, {24,-37,-10,-10,-3}, {-36,-45,-1,-18,1} }, // Ch1
        { {-38,-53,-53,-28,-66}, {-46,-25,-27,-8,-35}, {-41,-8,-4,1,-5}, {-47,13,13,4,27}, {58,25,7,27,18} }, // Ch2
        { {20,26,44,50,26}, {23,2,53,20,-6}, {-42,-14,49,25,-17}, {-79,-25,16,-12,-69}, {-103,30,8,-14,0} } // Ch3
    }
};
// Conv2 Bias (Filter 1: 0xCF, Filter 2: ???, Filter 3: 0xFD 추정)
// TODO: conv2_calc_X.v 파일의 마지막 줄 `+ 8'shXX` 값을 확인해서 수정하세요.
const signed char B_conv2[3] = {-6, 50, -20};


// --- FC Layer Weights (48 -> 10) ---
// TODO: fully_connected.v 파일의 가중치를 여기에 넣어야 합니다.
// (1차원 배열로 쭉 나열하거나 2차원 배열로 선언)
// FC Weights (10 Neurons, 48 Inputs each)
const signed char W_fc[10][48] = {
    {36, -25, -73, 3, -4, -8, -8, 15, 25, -16, -5, 34, 8, 45, -84, -30, 5, 17, -13, -28, 25, -41, -5, 17, 7, 39, -47, -66, -11, -19, -11, -15, 18, -32, 68, 31, 33, 53, 1, 18, -47, -11, 42, -69, -38, -7, 29, 46},
    {-21, 19, 11, -38, 41, -23, -45, -15, -99, -56, 16, -46, -11, -82, -25, 52, 52, 0, -33, 5, -8, -64, 30, -12, -39, -60, -64, 43, 89, -25, -62, -36, 42, -2, 11, 17, -11, 2, -24, -36, 78, -32, -18, 7, 2, 37, -78, 46},
    {-46, -30, 66, 21, 19, 43, 22, 36, 9, -58, -21, 5, -7, -74, 8, 13, -39, 22, -7, -14, 26, -67, 37, -3, 1, -33, -20, 15, -16, 29, -43, -17, 41, 11, 16, 25, 28, 64, -24, 13, 10, -21, 14, 5, -15, 95, -68, 57},
    {-23, -76, 57, 42, -8, 32, 59, 26, -9, -29, 38, 7, -43, -45, 40, 26, 12, 14, 27, -12, 7, 12, -14, -55, -23, -20, 2, -8, 28, -9, 7, 12, -14, 6, -7, -8, 1, -101, 21, 44, -33, -12, 18, -29, -49, -16, 46, -28},
    {-17, 24, -62, -76, -2, -93, -63, -1, -106, -98, 1, -95, 3, 47, 0, -6, -10, 13, -15, 28, 11, -2, 51, -30, 33, 12, 31, 47, -54, 28, 28, 0, 20, 43, -21, 25, -35, 8, 34, -62, 29, 24, -100, 27, 21, -22, -5, 70},
    {4, 26, -24, -20, -46, -23, 15, 14, -8, 100, 19, 27, 6, 36, -22, 8, 1, 15, 22, -8, -13, 2, -114, 26, -15, -35, 5, -3, 25, 2, -10, 9, -17, -13, -63, -15, -28, -81, 19, 73, -18, -10, 11, 13, -24, -23, 39, -49},
    {19, 67, -128, -31, 28, -114, -69, 42, -26, 72, -27, -24, 6, 45, -128, -25, -58, -40, -37, -36, 16, 0, -66, -39, 37, 35, -41, -32, -1, 9, 19, -21, 22, -18, -23, -17, -13, 33, -41, 12, 12, -4, 64, -22, -7, 33, 27, 3},
    {8, -66, 73, -3, -13, 51, -28, 4, 54, -26, 12, 54, -12, -27, 51, -2, -43, 22, 21, -30, 31, -29, -23, 26, 8, 13, 35, 29, 12, 7, -1, 49, 24, 40, 59, 26, -57, 18, 38, -81, 15, -23, -111, 0, 9, -54, -25, 76},
    {18, 31, -20, 13, -25, -11, 19, -2, -16, 41, 10, -8, 13, 6, -5, 19, -4, -24, 21, -26, -28, 23, 6, -42, -31, -22, -3, -28, 27, -11, -18, 5, -18, 5, -8, -27, 0, 25, -28, -18, -12, 2, 51, -25, -36, -8, -33, -51},
    {28, -14, -68, 2, -55, -23, 27, -23, 35, 17, -32, -4, -20, 59, -12, -3, -14, -13, 58, 32, -28, -14, 3, -41, -10, -2, 17, 25, 15, 17, 1, 47, -49, -3, 34, -44, -29, -32, 9, -36, -48, 44, -112, -4, -3, -65, 14, 32}
};

// FC Biases (10 Neurons)
const signed char B_fc[10] = { -72, 82, -54, -36, -5, -8, -48, -11, 52, 64 };

// ==========================================================================
// 2. 유틸리티 및 레이어 함수 (HW 동작 모사)
// ==========================================================================

// ReLU (0보다 작으면 0)
int relu(int x) {
    return (x < 0) ? 0 : x;
}

// [Layer 1] Conv1 + ReLU (SW 순차 처리)
void sw_layer1(unsigned char input[IMG_ROWS][IMG_COLS], int output[3][CONV1_ROWS][CONV1_COLS]) {
    for (int f = 0; f < 3; f++) { // Filter 3개
        for (int r = 0; r < CONV1_ROWS; r++) {
            for (int c = 0; c < CONV1_COLS; c++) {
                int sum = 0;
                // 5x5 MAC
                for (int kr = 0; kr < 5; kr++) {
                    for (int kc = 0; kc < 5; kc++) {
                        sum += (int)input[r+kr][c+kc] * W_conv1[f][kr][kc];
                    }
                }
                // Verilog Logic: ($signed(sum) >>> 7) + bias
                int res = (sum >> 7) + B_conv1[f];
                output[f][r][c] = relu(res); // ReLU 포함
            }
        }
    }
}

// [Layer 2] MaxPool1 (2x2)
void sw_layer2(int input[3][CONV1_ROWS][CONV1_COLS], int output[3][POOL1_ROWS][POOL1_COLS]) {
    for (int f = 0; f < 3; f++) {
        for (int r = 0; r < POOL1_ROWS; r++) {
            for (int c = 0; c < POOL1_COLS; c++) {
                int max = 0;
                // 2x2 Window search
                for (int kr = 0; kr < 2; kr++) {
                    for (int kc = 0; kc < 2; kc++) {
                        int val = input[f][r*2 + kr][c*2 + kc];
                        if (val > max) max = val;
                    }
                }
                output[f][r][c] = max;
            }
        }
    }
}

// [Layer 3] Conv2 (3D Tensor) + ReLU
void sw_layer3(int input[3][POOL1_ROWS][POOL1_COLS], int output[3][CONV2_ROWS][CONV2_COLS]) {
    for (int f = 0; f < 3; f++) { // Output Filter 3개
        for (int r = 0; r < CONV2_ROWS; r++) {
            for (int c = 0; c < CONV2_COLS; c++) {
                int total_sum = 0;

                // 3 Channel Depth Accumulation
                for (int ch = 0; ch < 3; ch++) {
                    int ch_sum = 0;
                    for (int kr = 0; kr < 5; kr++) {
                        for (int kc = 0; kc < 5; kc++) {
                            ch_sum += input[ch][r+kr][c+kc] * W_conv2[f][ch][kr][kc];
                        }
                    }
                    total_sum += ch_sum;
                }

                // Verilog Logic: Shift and Bias
                int res = (total_sum >> 7) + B_conv2[f];
                output[f][r][c] = relu(res);
            }
        }
    }
}

// [Layer 4] MaxPool2 (2x2)
void sw_layer4(int input[3][CONV2_ROWS][CONV2_COLS], int output[3][POOL2_ROWS][POOL2_COLS]) {
    for (int f = 0; f < 3; f++) {
        for (int r = 0; r < POOL2_ROWS; r++) {
            for (int c = 0; c < POOL2_COLS; c++) {
                int max = 0;
                for (int kr = 0; kr < 2; kr++) {
                    for (int kc = 0; kc < 2; kc++) {
                        int val = input[f][r*2 + kr][c*2 + kc];
                        if (val > max) max = val;
                    }
                }
                output[f][r][c] = max;
            }
        }
    }
}

// [Layer 5&6] Flatten & FC
void sw_layer_fc(int input[3][POOL2_ROWS][POOL2_COLS], int output[FC_OUTPUT_NODES]) {
    // Flatten
    int flat[FC_INPUT_NODES];
    int idx = 0;
    for (int f = 0; f < 3; f++) {
        for (int r = 0; r < POOL2_ROWS; r++) {
            for (int c = 0; c < POOL2_COLS; c++) {
                flat[idx++] = input[f][r][c];
            }
        }
    }

    // Matrix Mult
    for (int i = 0; i < FC_OUTPUT_NODES; i++) {
        int sum = 0;
        for (int j = 0; j < FC_INPUT_NODES; j++) {
            sum += flat[j] * W_fc[i][j];
        }
        output[i] = sum + B_fc[i]; // FC는 보통 Shift 안하지만 코드 확인 필요
    }
}


unsigned char test_img[784] __attribute__ ((aligned (32))) = {
    // 0~6: 여백
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    // Row 6~7: 상단 가로바 (깔끔한 직선, 두께 2px)
    0,0,0,0,0,0,0,127,127,127,127,127,127,127,127,127,127,127,127,127,127,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,127,127,127,127,127,127,127,127,127,127,127,127,127,127,0,0,0,0,0,0,0,

    // Row 8~9: 오른쪽 꺾임 (9처럼 보이지 않게 뭉침 방지)
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,

    // Row 10~18: 대각선 (계단 현상을 막기 위해 겹쳐서 배치)
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    // Row 19~20: 하단 끝처리
    0,0,0,0,0,0,0,127,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,127,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,

    // 21~27: 여백
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
int sw_output[3][CONV1_ROWS][CONV1_COLS];
// ==========================================================================
// 3. Main Function
// ==========================================================================
int main()
{
    XTime t_start, t_end;

    printf("--- Benchmark Start ---\n\r");

    // [Software 측정 시작]
    XTime_GetTime(&t_start);

    // ----------------------------------------------------------------
    // [핵심] 1차원 배열을 2차원인 척 던져주기 (캐스팅)
    // 설명: (unsigned char (*)[28]) 은 "이 포인터를 가로길이 28짜리 2차원 배열로 봐라"는 뜻입니다.
    // ----------------------------------------------------------------
    sw_layer1((unsigned char (*)[28])test_img, sw_output);

    XTime_GetTime(&t_end);
    // [Software 측정 끝]


    // 시간 계산 (us 단위)
    u64 sw_cycles = 2 * (t_end - t_start);
    double sw_time_us = (double)sw_cycles / (double)CPU_CLOCK_HZ * 1000000.0;

    printf("[Software] Time: %.3f us (Cycles: %llu)\n\r", sw_time_us, sw_cycles);


    // ----------------------------------------------------------------
    // [Hardware 비교]
    // ----------------------------------------------------------------
    u64 hw_cycles = 2787; // 님께서 측정한 사이클 수 (예시)

    // 여기서 10MHz로 나눕니다 (중요!)
    double hw_time_us = (double)hw_cycles / (double)PL_CLOCK_HZ * 1000000.0;

    printf("[Hardware] Time: %.3f us (Cycles: %llu @ 10MHz)\n\r", hw_time_us, hw_cycles);


    // 속도 비교
    if (hw_time_us > 0) {
        double speedup = sw_time_us / hw_time_us;
        printf(">> Speedup: x%.2f \n\r", speedup);
    }

    return 0;
}
